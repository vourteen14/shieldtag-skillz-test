# Security Implementation & Library Documentation

## Security Measures Implemented

### 1. Password Security
- **Argon2id Hashing**

    Implemented Argon2id with parameters `timeCost: 3` and `memoryCost: 64MB` for password hashing. Argon2id is the winner of the Password Hashing Competition and provides better resistance against GPU/ASIC attacks compared to bcrypt

- **Automatic Salt Generation**

    Each password receives a unique salt automatically generated by Argon2

### 2. Token-based Authentication
- **Dual Token Strategy**

    Access tokens (15 minutes) stored in frontend memory, refresh tokens (7 days) stored in HttpOnly cookies and PostgreSQL database

- **JWT Signing**

    Uses HS256 with different secret keys for access and refresh tokens

- **Automatic Token Refresh**

    Implemented interceptor in frontend to automatically refresh tokens before expiration

### 3. Input Validation & Sanitization
- **Backend Validation**

    express-validator with custom rules for email format, password strength (minimum 8 characters, combination of uppercase/lowercase/numbers/symbols)

- **Frontend Validation**

    Real-time validation with visual feedback for better user experience

- **HTML Encoding**

    All user input is encoded to prevent XSS attacks

### 4. Attack Prevention
- **SQL Injection**

    Uses Sequelize ORM with parameterized queries, no raw SQL exposure

- **XSS Protection**

    Helmet.js for security headers (CSP, X-XSS-Protection), plus input sanitization

- **Brute Force Protection**

    Rate limiting of 5 attempts per 5 minutes per IP address on login endpoint

- **CSRF Prevention**

    HttpOnly cookies with SameSite=Strict attribute, refresh token endpoint with path-based protection

### 5. Database & Infrastructure Security
- **Environment Variables**

    All credentials stored in environment variables, no hardcoded values in source code

- **Connection Security**

    PostgreSQL connection with SSL/TLS encryption

- **Error Handling**

    Generic error messages to client, detailed logs only on server to prevent information disclosure

### 6. Additional Security Layers
- **CORS Configuration**

    Whitelist specific origins, no wildcard (*) usage

- **HTTP Security Headers**

    Helmet.js configures headers like HSTS, X-Frame-Options, Content-Security-Policy

- **Request Size Limiting**

    Limits request body size to prevent DoS attacks

## Libraries Used & Rationale

### Backend Libraries

| Library | Function | Selection Rationale |
|---------|----------|---------------------|
| **argon2** | Password hashing | Winner of Password Hashing Competition, more secure than bcrypt, resistant to GPU attacks |
| **jsonwebtoken** | JWT handling | Industry standard for stateless authentication, supports various algorithms |
| **express-validator** | Input validation | Mature library with extensive validation rules, well-integrated with Express |
| **helmet** | Security headers | Comprehensive security headers in one package, maintained by Express team |
| **express-rate-limit** | Rate limiting | Simple and effective for brute force prevention, supports various storage backends |
| **sequelize** | ORM | Type-safe queries, built-in SQL injection protection, excellent migration support |
| **cors** | CORS handling | Fine-grained control over cross-origin requests, security-focused configuration |

### Frontend Libraries

| Library | Function | Selection Rationale |
|---------|----------|---------------------|
| **axios** | HTTP client | Interceptor support for auto token refresh, better error handling than fetch API |
| **js-cookie** | Cookie management | Lightweight library for client-side cookie handling with security options |
| **tailwindcss** | CSS framework | Utility-first approach for rapid development, built-in responsive design |

## Security Trade-offs & Considerations

### Why Not Redis for Token Storage?
Chose PostgreSQL for refresh token storage because:
- **Consistency**

    ACID properties for data integrity

- **Simplicity**

    Reduces infrastructure complexity

- **Audit Trail**

    Easy tracking and logging of token usage

### Why Dual Token Strategy?
- **Security**

    Short-lived access tokens reduce attack window

- **User Experience**

    Refresh tokens enable longer sessions without re-login

- **Revocation**

    Database-stored refresh tokens allow immediate revocation

### Performance vs Security Balance
- Rate limiting may impact performance but necessary for security
- Password hashing with Argon2 slower than bcrypt but more secure
- Token validation on every request adds latency but ensures authorization

## Security Metrics Achieved
- OWASP Top 10 Protection => Covered injection, XSS, authentication flaws
- Industry Standards => Following JWT RFC 7519, OAuth 2.0 best practices  
- Zero Known Vulnerabilities => All dependencies updated and vulnerability-free
- Defense in Depth => Multiple security layers from input validation to database level
